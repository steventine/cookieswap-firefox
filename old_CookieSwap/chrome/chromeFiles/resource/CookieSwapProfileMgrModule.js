var EXPORTED_SYMBOLS = ["getCookieSwapProfileMgrModule", 
                        "getCookieSwapVersion", 
                        "initCookieManagerModule", 
                        "releaseCookieSwapProfileMgrModule",
                        "anyOpenPrivateBrowsingWindows"];

//-----------------------------
//interfaces we support
const nsIProfile = Components.interfaces.nsIProfile;       //For profile management
const nsIPrefBranch = Components.interfaces.nsIPrefBranch; //For generic get/set
const nsIObserver = Components.interfaces.nsIObserver;     //For ? (console was throwing an error that this wasn't implemented)

//-----------------------------
//Observer notifications generated by this component

//The observer topic used during notifies from this component
const COOKIE_SWAP_OBSERVER_TOPIC = "cookie_swap";

//The observer data used during notifies from this component
const COOKIE_SWAP_RELOAD_DATA = "?RELOAD?";
const COOKIE_SWAP_PRIV_BROWSING_DATA = "?PRIV_BROWSING?";  //Also a boolPref
const COOKIE_SWAP_NOT_PRIV_BROWSING_DATA = "?NOT_PRIV_BROWSING?";

const COOKIE_SWAP_VER_DATA = "?VERSION?";  //For getCharPref

//-------------------------------
//Meaning of the network.cookie.cookieBehavior setting
const COOKIE_BEHAVIOR_ACCEPT_ALL = 0;
const COOKIE_BEHAVIOR_DISALLOW_THIRD_PARTY = 1;
const COOKIE_BEHAVIOR_DISABLE_COOKIES = 2;

//These are the constants used in the cookieswap_swap observer 'subject'
const COOKIE_SWAP_OBSVR_NEW_ACTIVE_PROFILE=1;
const COOKIE_SWAP_OBSVR_NEW_PROFILE_LIST=2;

//Exceptions we throw
const ATTEMPT_TO_DELETE_ACTIVE_PROFILE = "Can't delete the active profile";
const INTERNAL_ERROR = "Unspecified internal error";

//To make it more efficient to get preferences, get the pref
//  branch once
var gCsPrefs = Components.classes["@mozilla.org/preferences-service;1"]
                    .getService(Components.interfaces.nsIPrefService)
                    .getBranch("extensions.cookieswap.");

var gCookieSwapVersionNumber=null;

const PROF_ARRAY_REGULAR_BROWSING_INDEX = 0;
const PROF_ARRAY_PRIVATE_BROWSING_INDEX = 1;
var gCookieProfileMgrArray = null;

function CookieSwapVersionNumber() {  
  //Initialize the version number store
  cookieswap_initializeVersion(this);
}

//class definition
CookieSwapVersionNumber.prototype = {
  _version: "<unknown>"
};

function initCookieManagerModule() {
   if (gCookieSwapVersionNumber == null)
   {
      //First time that init is called
	  
	  //Initialize the logger
      cookieswap_loggerInit();
	  
	  //Create the profile manager array
	  gCookieProfileMgrArray = new Array();
	  gCookieProfileMgrArray[PROF_ARRAY_PRIVATE_BROWSING_INDEX] = new Object();
	  gCookieProfileMgrArray[PROF_ARRAY_PRIVATE_BROWSING_INDEX].profileMgr = null;
	  gCookieProfileMgrArray[PROF_ARRAY_PRIVATE_BROWSING_INDEX].refCount = 0;
	  
	  gCookieProfileMgrArray[PROF_ARRAY_REGULAR_BROWSING_INDEX] = new Object();
	  gCookieProfileMgrArray[PROF_ARRAY_REGULAR_BROWSING_INDEX].profileMgr = null;
	  gCookieProfileMgrArray[PROF_ARRAY_REGULAR_BROWSING_INDEX].refCount = 0;
	  
	  //Create the CookieSwapVersionNumber holder
      gCookieSwapVersionNumber = new CookieSwapVersionNumber();
   }
   
   return;
}
  
function getCookieSwapVersion(){
   return(gCookieSwapVersionNumber._version);
}

//This is the only exported method from this module.  It manages the instances of
// the CookieSwapProfileManagers.  There are two CookieSwapProfileManagers:
//  isPrivate=true is the profile manager used when in private browsing
//  isPrivate=false is the profile manager used when in normal (non-private) browsing
function getCookieSwapProfileMgrModule(isPrivate) {
   var index;
   if (isPrivate)
   {
      //Request is for the Private mode CookieSwapProfileMgr
      index=PROF_ARRAY_PRIVATE_BROWSING_INDEX;
   }
   else
   {
      //Request is for the normal (non-Private) mode CookieSwapProfileMgr
      index=PROF_ARRAY_REGULAR_BROWSING_INDEX;
   }
   
   if (gCookieProfileMgrArray[index].profileMgr == null)
   {
       gCookieProfileMgrArray[index].profileMgr = new CookieSwapProfileMgr(isPrivate);
       gCookieProfileMgrArray[index].refCount = 0;

       //-------TEMPORARY...per ticket #88------
       //-------FF19 and earlier had a global Private Browsing mode
       //-------FF20 and later had per window Private Browsing but doesn't have a CookieManager
       //            that allows you to manipulate the priv/pub cookie store independently
       //Per ticket #88: In FF 20 (which has per window priv browsing)
       //  we have to treat the entire browser as being in private browsing
       //  whenever at least 1 window is private browsing because the CookieManager
       //  doesn't allow you to change only the private or public cookie store.
       //  So, notify the regular windows that we are in PRIV browsing as well.       
       //See Mozilla bug https://bugzilla.mozilla.org/show_bug.cgi?id=777620
       var appInfo = Components.classes["@mozilla.org/xre/app-info;1"]
                             .getService(Components.interfaces.nsIXULAppInfo);
       var versionChecker = Components.classes["@mozilla.org/xpcom/version-comparator;1"]
                                    .getService(Components.interfaces.nsIVersionComparator);
       if(versionChecker.compare(appInfo.version, "20") >= 0) 
       {
           //If we just created a private browsing window, or
           //   we just created a reglar window and there are private windows still open
           //Then notify the regluar windows that we are private browsing
           if ((index == PROF_ARRAY_PRIVATE_BROWSING_INDEX) ||
                  ((index == PROF_ARRAY_REGULAR_BROWSING_INDEX) && 
                   (gCookieProfileMgrArray[PROF_ARRAY_PRIVATE_BROWSING_INDEX].refCount > 0)))
           {
               cookieswap_dbg("In FF20+ and a priv browsing is open.  Notify regular windows of PRIV browsing");
               if(gCookieProfileMgrArray[PROF_ARRAY_REGULAR_BROWSING_INDEX].profileMgr != null)
               {
                   //Notify the reglar browsing window that we are in priv browsing
                   gCookieProfileMgrArray[PROF_ARRAY_REGULAR_BROWSING_INDEX].profileMgr.notifyObserversOfPrivBrowsing();
               }
           }
       }
   }
   gCookieProfileMgrArray[index].refCount++;
   return (gCookieProfileMgrArray[index].profileMgr);   
 }
 
function anyOpenPrivateBrowsingWindows() 
{
    //If we have any private profile managers then we have at least one window in private browsing state
    return(gCookieProfileMgrArray[PROF_ARRAY_PRIVATE_BROWSING_INDEX].refCount > 0);
}

//This is called when a ProfileManger is no longer needed.  Once all references
//  have been released, the ProfileManager can be released.
function releaseCookieSwapProfileMgrModule(profMgr){
 cookieswap_dbg("releaseCookieSwapProfileMgrModule\n");
 
  for (i=0;i<gCookieProfileMgrArray.length;i++)
  {
     if(gCookieProfileMgrArray[i].profileMgr == profMgr)
	 {
	    cookieswap_dbg("Found profile mgr at index " + i + " with refcount of " + gCookieProfileMgrArray[i].refCount);
	    //Is this the last outstand reference?
		gCookieProfileMgrArray[i].refCount--;
	    if(gCookieProfileMgrArray[i].refCount <= 0)
	    {
	        //This is the last reference needed of this type of profile manager.

	        //-------TEMPORARY...per ticket #88------
	        if (i == PROF_ARRAY_PRIVATE_BROWSING_INDEX)
	        {
	            //-------FF19 and earlier had a global Private Browsing mode
	            //-------FF20 and later had per window Private Browsing but doesn't have a CookieManager
	            //            that allows you to manipulate the priv/pub cookie store independently
	            var appInfo = Components.classes["@mozilla.org/xre/app-info;1"]
                                      .getService(Components.interfaces.nsIXULAppInfo);
	            var versionChecker = Components.classes["@mozilla.org/xpcom/version-comparator;1"]
                                             .getService(Components.interfaces.nsIVersionComparator);
	            if(versionChecker.compare(appInfo.version, "20") >= 0) 
	            {
	                //Per ticket #88: In FF 20 (which has per window priv browsing)
	                //  we have to treat the entire browser as being in private browsing
	                //  whenever at least 1 window is private browsing because the CookieManager
	                //  doesn't allow you to change only the private or public cookie store.
	                //However, this is the last window in private browsing, so we can now tell
                    //  the regular windows that we are no longer in private browsing.
	                //See Mozilla bug https://bugzilla.mozilla.org/show_bug.cgi?id=777620
	                cookieswap_dbg("In FF20+ and last priv browsing window is gone.  Notify regular windows of NOT PRIV browsing");
	                if(gCookieProfileMgrArray[PROF_ARRAY_REGULAR_BROWSING_INDEX].profileMgr != null)
	                {
	                    gCookieProfileMgrArray[PROF_ARRAY_REGULAR_BROWSING_INDEX].profileMgr.notifyObserversOfNotPrivBrowsing();
	                }
	            }
	        }

  		    cookieswap_dbg("Destroying profile mgr at index " + i);
		    //No longer needed...release it for the garbage collector
			gCookieProfileMgrArray[i].profileMgr = null;
		}
	 }
  }
} 
 
//class constructor
//  isPrivate=true is the profile manager used when in private browsing
//  isPrivate=false is the profile manager used when in normal (non-private) browsing
function CookieSwapProfileMgr(isPrivate) {
  cookieswap_dbg("CookieSwapProfileMgr(" + isPrivate + ") ctor\n");

  //-------FF19 and earlier had a global Private Browsing mode
  //-------FF20 and later had per window Private Browsing
  var appInfo = Components.classes["@mozilla.org/xre/app-info;1"]
                        .getService(Components.interfaces.nsIXULAppInfo);
  var versionChecker = Components.classes["@mozilla.org/xpcom/version-comparator;1"]
                               .getService(Components.interfaces.nsIVersionComparator);
  if(versionChecker.compare(appInfo.version, "20") >= 0) 
  {
      //This is version FF20+
      cookieswap_dbg("FF20+ means we are assuming per-window private browsing");
	 
	  this._isPrivate = isPrivate;
  }
  else
  {
	  //Register an observer to catch when we are private browsing
	  gPrivBrowsingObserver = new cookieswap_PrivateBrowsingListener();

	  //This should only be called on FF19 and earlier.  In FF20, each window is
	  //  Private Browsing or not.
	  gPrivBrowsingObserver.watcher = 
	  {
		 _csProfileMgr: null,

		 get csProfileMgr() { return this._csProfileMgr; },
		 set csProfileMgr(aValue) { this._csProfileMgr = aValue; },

		 onEnterPrivateBrowsing: function()
		 {
			//Reinit to non-persistent storage
			cookieswap_dbg("Entering Private Browsing\n");
			this._csProfileMgr.setPrivBrowsingState(true);
		 },

		 onExitPrivateBrowsing: function()
		 {
			//Reinit to persistent storage
			cookieswap_dbg("Exiting Private Browsing\n");
			this._csProfileMgr.setPrivBrowsingState(false);
		 },
	  }; 
	  
	  this._isPrivate = gPrivBrowsingObserver.inPrivateBrowsing;
	  
	  //Set the ProfileMgr to the watcher so it can call back here when notified
	  gPrivBrowsingObserver.watcher.csProfileMgr = this; 
  }
	 
  //Now get the CookieProfileContainer singleton which initializes it
  this._profileContainer = new CookieProfileContainer(isPrivate);

  //Show the currently active profile as active on the UI
  this._currentProfile = this._profileContainer.getActiveProfileId();
  
  
  cookieswap_dbg("CookieSwapProfileMgr ctor complete\n");
};


//class definition
CookieSwapProfileMgr.prototype = {
  _currentProfile: null,
  _profileContainer: null,
  _version: "<unknown>",
  _isPrivate: false,

  //--------------------------------------------------------
  //property of nsIProfile interface (setter/getter methods)
  //--------------------------------------------------------
  get currentProfile() { return this._currentProfile; },
  set currentProfile(aValue) { this.changeCurrentProfile(aValue); },
  get profileCount() { return this._profileContainer.getNumOfProfiles(); },
  
  //-------------------------------
  //methods of nsIPrefBranch interface
  //-------------------------------

  //----getBoolPref-----
  getBoolPref: function(prefName) {
    cookieswap_dbg("getBoolPref(" + prefName + ")\n");
    var  bool_ret_val;
    if (prefName == COOKIE_SWAP_PRIV_BROWSING_DATA)
    {
       bool_ret_val = this._profileContainer.getPrivBrowsing();
    }
    return bool_ret_val;
  },

  //----getCharPref-----
  getCharPref: function(prefName) {
    cookieswap_dbg("getCharPref(" + prefName + ")\n");
    var  char_ret_val;
    if (prefName == COOKIE_SWAP_VER_DATA)
    {
       //CookieSwap version number
       char_ret_val = this._version;
    }
   cookieswap_dbg("Pref value returned is '" + char_ret_val + "'\n");
   return char_ret_val;
  },



  //-------------------------------
  //methods of nsIProfile interface
  //-------------------------------

  //----cloneProfile-----
  //In cookieSwap...we don't know the profile being cloned so we squeeze the
  //  original profile name and new profile name into the "profName" and split it using
  //  a seemingly impossible valid name delimiter " , "
  //So profName is "oldProfileName , newProfName" (with <space> <comma> <space> inbetween)  
  cloneProfile: function(profName) {
    cookieswap_dbg("cloneProfile " + profName + "\n");
    
    var split_string = profName.split(" , ");
    if (split_string.length > 1)
    {
       var oldProfName = split_string[0];
       var newProfName = split_string[1];

       cookieswap_dbg("Request to copy " + oldProfName + " to " + newProfName + "\n");
       var profile_num = this._profileContainer.getProfileNum(oldProfName);
       if(profile_num != INVALID_PROFILE_NUM)
       {
          //Go ahead and copy the profile
          cookieswap_dbg("Copying profile:" + oldProfName + " (" + profile_num + ") to " + newProfName + "\n");
          if (this._profileContainer.copyProfile(profile_num, newProfName) == true)
          {
             this._currentProfile = this._profileContainer.getActiveProfileId();
             this.notifyObserversOfNewProfileList();
          }
       }
       else
       {
          cookieswap_dbg("Request to copy invalid profile: " + oldProfName + "\n");
          throw(INTERNAL_ERROR);
       }
    }
    else
    {
       cookieswap_dbg("Split failed with only " + split_string.length  + " strings returned\n");
       throw(INTERNAL_ERROR);
    }

    return;
  },    

  //-------------------------------
  //methods of nsIObserver interface
  //-------------------------------
  observe: function (aSubject, aTopic, aData) {
    cookieswap_dbg("observe method in CookieSwapProfManager unimplemented Topic=" + aTopic + "\n");
    //Unimplemented, we could throw an exception
    //throw("cloneProfile unimplemented");
    return;
  },

  //---createNewProfile-----
  //---Only use the profName for CookieSwap
  createNewProfile: function(profName, profDir, langCode, useExistingDir) {
    cookieswap_dbg("Creating" + profName + "\n");
    if (this._profileContainer.addProfile(profName) == true)
    {
       this.notifyObserversOfNewProfileList();
    }
  },

  //---deleteProfile-----
  //---CookieSwap changes the definition of this method slightly.  If
  //---  canDeleteFile is true then the profile is completely deleted and
  //---  removed as a profile.  If canDeleteFile is false, then the contents
  //---  (i.e. cookies) of the profile are deleted, but the profile still
  //---  exists.
  deleteProfile: function(profName, canDeleteFile) {
    cookieswap_dbg("Deleting" + profName + "\n");
    if (canDeleteFile == true)
    {
       //Request to delete the entire profile
       if (profName != this._currentProfile)
       {
          var profile_num = this._profileContainer.getProfileNum(profName);
          if(profile_num != INVALID_PROFILE_NUM)
          {
             //Go ahead and delete the profile
             cookieswap_dbg("Deleting profile:" + profName + " (" + profile_num + ")\n");
             if (this._profileContainer.removeProfile(profile_num) == true)
             {
                this._currentProfile = this._profileContainer.getActiveProfileId();
                this.notifyObserversOfNewProfileList();
             }
             else
             {
                cookieswap_dbg("removeProfile() call failed");
             }
          }
          else
          {
             cookieswap_dbg("Request to delete invalid profile: " + profName + "\n");
          }
       }
       else
       {
          cookieswap_dbg("Request to delete active profile");
          throw(ATTEMPT_TO_DELETE_ACTIVE_PROFILE);
       }
    }
    else
    {
       //Request to delete the cookies in this profile
       cookieswap_dbg("Deleting cookies associated with " + profName + "\n");
       var req_profile = this._profileContainer.getProfile(profName);
       if (req_profile != null)
       {
          //Clear all cookies in the requested profile
          req_profile.clearAllCookies();
       }
       else
       {
          cookieswap_dbg("Invalid profile name [" + profName + "] passed in\n");
       }
    }

  },

  //---getProfileList-----
  getProfileList: function(obj) {
    var profile_array = new Array();

    //Populate the UI with the profiles available
    for(var i=0; i<this._profileContainer.getNumOfProfiles(); i++)
    {
       profile_array[i] = this._profileContainer.getProfileName(i);
       cookieswap_dbg("Returning profile: " + profile_array[i]);
    }

    obj.value = profile_array.length;

    return profile_array;
  },
  
  //---profileExists-----
  profileExists: function(profName) {
    var profile_num = this._profileContainer.getProfileNum(profName);
    if(profile_num != INVALID_PROFILE_NUM)
        return true;
    else
        return false; 
  },

  //---renameProfile-----
  renameProfile: function(oldProfName, newProfName) {
    cookieswap_dbg("Request to rename from " + oldProfName + " to " + newProfName + "\n");
    var profile_num = this._profileContainer.getProfileNum(oldProfName);
    if(profile_num != INVALID_PROFILE_NUM)
    {
       //Go ahead and delete the profile
       cookieswap_dbg("Renaming profile:" + oldProfName + " (" + profile_num + ") to " + newProfName + "\n");
       if (this._profileContainer.renameProfile(profile_num, newProfName) == true)
       {
          this._currentProfile = this._profileContainer.getActiveProfileId();
          this.notifyObserversOfNewProfileList();
       }
    }
    else
    {
       cookieswap_dbg("Request to delete invalid profile: " + oldProfName + "\n");
    }

  },
  
  //---shutDownCurrentProfile-----
  shutDownCurrentProfile: function(type) {
    cookieswap_dbg("Shutdown type= " + type + "\n");
  },

  //--------------------------------------------------------------------------
  //Private methods of CookieSwapProfileMgr (not part of an exposed Interface)
  //--------------------------------------------------------------------------
  //---setPrivBrowsingState (only happens in FF19 and earlier)-----
  setPrivBrowsingState: function(newPrivBrowsingState) {
    cookieswap_dbg("Setting Priv Browsing state to " + newPrivBrowsingState + "\n");

    if (this._isPrivate != newPrivBrowsingState)
    {
       cookieswap_dbg("Changing Priv Browsing state to " + newPrivBrowsingState + "\n");
	   
	   this._isPrivate = newPrivBrowsingState
	   
	   //Create a new profileContainer with the new browsing state
       this._profileContainer = new CookieProfileContainer(this._isPrivate);
       
       //To be safe, notify all windows of new profiles and new active profile.
	   //For example, this can happen when leaving private browsing and the profiles
       //  that was active when the user entered private browsing is again active.
       this._currentProfile = this._profileContainer.getActiveProfileId();
       this.notifyObserversOfNewProfileList();
       this.notifyObserversOfSwap(this._currentProfile);

       if (this._isPrivate == true)
       {
          this.notifyObserversOfPrivBrowsing();
       }
       else
       {
          this.notifyObserversOfNotPrivBrowsing();
       }
    }
	cookieswap_dbg("Change to Priv Browsing state complete");
  },

  //----notifyObserversOfSwap-----
  notifyObserversOfSwap: function(profName) {
     //Create a wrappedJSObject for the subject
      var subj = {
          cookieSwapProfileMgr : this,
          extraData: null
     };
     subj.wrappedJSObject = subj;

     //Notify all the observers of the new profiles swapped in
     Components.classes["@mozilla.org/observer-service;1"]
         .getService(Components.interfaces.nsIObserverService)
         .notifyObservers(subj, "cookieswap_swap", profName);
  },

  //----notifyObserversOfNewProfileList-----
  notifyObserversOfNewProfileList: function() {
      //Create a wrappedJSObject for the subject
      var subj = {
          cookieSwapProfileMgr : this,
          extraData: null
      };
      subj.wrappedJSObject = subj;

     //Notify all the observers of the new profile list
     Components.classes["@mozilla.org/observer-service;1"]
         .getService(Components.interfaces.nsIObserverService)
         .notifyObservers(subj, "cookieswap_swap", COOKIE_SWAP_RELOAD_DATA);
  },

  //----notifyObserversOfPrivBrowsing-----
  notifyObserversOfPrivBrowsing: function() {
       //Create a wrappedJSObject for the subject
      var subj = {
          cookieSwapProfileMgr : this,
          extraData: null
      };
      subj.wrappedJSObject = subj;

     //Notify all the observers that we are private browsing
     Components.classes["@mozilla.org/observer-service;1"]
         .getService(Components.interfaces.nsIObserverService)
         .notifyObservers(subj, "cookieswap_swap", COOKIE_SWAP_PRIV_BROWSING_DATA);
  },

  //----notifyObserversOfNotPrivBrowsing-----
  notifyObserversOfNotPrivBrowsing: function() {
      //Create a wrappedJSObject for the subject
      var subj = {
          cookieSwapProfileMgr : this,
          extraData: null
      };
      subj.wrappedJSObject = subj;

     //Notify all the observers that we are private browsing
     Components.classes["@mozilla.org/observer-service;1"]
         .getService(Components.interfaces.nsIObserverService)
         .notifyObservers(subj, "cookieswap_swap", COOKIE_SWAP_NOT_PRIV_BROWSING_DATA);
  },

  //----changeCurrentProfile-----
  changeCurrentProfile: function(profName) {
    cookieswap_dbg("changeCurrentProfile to " + profName + "\n");
    this._currentProfile = profName;

   cookieswap_dbg("START switchProfile to " + profName);

   var old_profile_id = this._profileContainer.getActiveProfileId();
   var new_profile_id = profName;

   //First thing to do is copy all the cookies from the browser and
   //  save them to the profile being swapped out
   if (old_profile_id != INVALID_PROFILE_ID)
   {
      cookieswap_dbg("Starting copyFromBrowser");
      var old_profile = this._profileContainer.getProfile(old_profile_id);
      old_profile.copyFromBrowser();
   }
   else
   {
      //The only normal case where this should happen is if the browser crashes
      //  during a swap and we come up and no profiles are active.  On the next
      //  first swap, the old profile will be INVALID
      cookieswap_dbg("Profile out is invalid...an ERROR if not the first swap after a crash");
   }

   //Next thing to do is to remove the cookies from the browser and copy
   //  in all the cookies associated with the profile being swapped in.
   //BUT, first ensure we set the ActiveProfileID to INVALID so that if
   //  we were to crash, all our profiles will be intact in persistent
   //  memory and we won't come up thinking that the cookies in the browers
   //  are associated with any profile.
   cookieswap_dbg("Setting to INVALID_PROFILE_ID");
   this._profileContainer.setActiveProfileId(INVALID_PROFILE_ID);
   this.notifyObserversOfSwap(INVALID_PROFILE_ID);

   //Remove all the browser cookies
   cookieswap_dbg("removingAllCookies");
   cookieswap_removeAllCookies();
  
   if (new_profile_id != INVALID_PROFILE_ID)
   {
      //Now swap in the cookies from the profile to the browser
      var new_profile = this._profileContainer.getProfile(new_profile_id);
      var prev_third_party_setting;

      //An unanticipated side effect of disabling ThirdPartyCookies is that
      //  CookieSwap is considered a third-party and so FF does not accept
      //  the cookies we pass to it.  To get around this, we will change the
      //  the user's setting for the short time we are writing to the cookie store.
      //Keep the previous value around so we can switch it back.
      cookieswap_dbg("Enabling third party cookies");
      prev_third_party_setting = this.changeThirdPartyCookieSetting(COOKIE_BEHAVIOR_ACCEPT_ALL);

      cookieswap_dbg("Starting copyToBrowser");
      new_profile.copyToBrowser();
     
      //Switching the setting back the user's original value 
      cookieswap_dbg("Changing third party cookie setting back to " + prev_third_party_setting);
      this.changeThirdPartyCookieSetting(prev_third_party_setting);

      cookieswap_dbg("Setting activeProfileID to " + new_profile_id);
      this._profileContainer.setActiveProfileId(new_profile_id);
      this.notifyObserversOfSwap(new_profile_id);

      cookieswap_dbg("Swap from profile " + old_profile_id + " to " + new_profile_id + " complete");
   }
   else
   {
      alert("[cookieswap] Internal error, profile in is invalid...no cookies swapped in");
   }
   
   cookieswap_dbg("END switchProfile");
  },

  //----changeThirdPartyCookieSetting-----
  //In FF, if the user has selected to not allow ThirdPartyCookies
  //  (via Tools->Options->Privacy->Cookies in FF 3.0) then FF will
  //  not accept the cookies passed to the cookie store from CookieSwap
  //This method allows us to modify that setting temporarly while we
  //  write the cookies to the store (since we aren't the intended
  //  target of this setting).
  //This method changes the ThirdPartyCookieSetting to the value passed
  //  in and passes back the previous value of the setting.
  changeThirdPartyCookieSetting: function(newVal) {
   var cookieBehaviorVal;

   cookieswap_dbg("START changeThirdPartyCookieSetting()");

   var net_pref = Components.classes['@mozilla.org/preferences-service;1']
                 .getService(Components.interfaces.nsIPrefService);
   cookieswap_dbg("got net_pref");

   //Get the branch containing the setting
   net_pref = net_pref.getBranch('network.cookie.');
   cookieswap_dbg("got network.cookie. branch");

   //Get the current value to pass back to the caller
   cookieBehaviorVal= net_pref.getIntPref('cookieBehavior'); 
   cookieswap_dbg("Currently cookieBehavior int is " + cookieBehaviorVal);

   //Setting the behavior to the value passed int.
   net_pref.setIntPref('cookieBehavior', newVal); 
   cookieswap_dbg("set to " + newVal);

   cookieswap_dbg("END changeThirdPartyCookieSetting()");

   return(cookieBehaviorVal);
  },


  //-------------------------------
  //method of nsISupports interface
  //-------------------------------
  QueryInterface: function(aIID)
  {
    if (!aIID.equals(nsIProfile) &&    
        !aIID.equals(nsISupports) &&
        !aIID.equals(nsIPrefBranch) &&
        !aIID.equals(nsIObserver))
      throw Components.results.NS_ERROR_NO_INTERFACE;
    return this;
  }
};

function cookieswap_removeAllCookies()
{
   var cookie_mgr = ffGetCookieManager();
   cookie_mgr.removeAll();
   cookieswap_dbg("All cookies removed");
}

// *****************************************************************************
// *                    CookieProfileContainer Class                           *
// *                                                                           *
// ************************** Coding Standards *********************************
// *  gMyVariable     - global variable (starts with "g", then mixed case)     *
// *  myVariable      - variables passed into functions                        *
// *  my_variable     - local variable inside of a function                    *
// *  this.myVariable - class attributes/variable (mixed case & always         *
// *                    referenced with "this.")                               *
// *  MyFunction      - functions are always mixed case                        *
// *  MY_CONSTANT     - constants are all caps with underscores                *
// *                                                                           *
// *************************** Revision History ********************************
// *  Name       Date       BugzID  Action                                     *
// *  ---------  ---------  -----   ------                                     *
// *  SteveTine  28Dec2005  12561   Initial Creation                           *
// *  SteveTine  30Sep2006  15281   Dealing with difference in moveTo on Linux *
// *                                                                           *
// ************************* BEGIN LICENSE BLOCK *******************************
// * Version: MPL 1.1                                                          *
// *                                                                           *
// *The contents of this file are subject to the Mozilla Public License Version*
// * 1.1 (the "License"); you may not use this file except in compliance with  *
// * the License. You may obtain a copy of the License at                      *
// * http://www.mozilla.org/MPL/                                               *
// *                                                                           *
// * Software distributed under the License is distributed on an "AS IS" basis,*
// * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License  *
// * for the specific language governing rights and limitations under the      *
// * License.                                                                  *
// *                                                                           *
// * The Original Code is the CookieSwap Mozilla/Firefox Extension             *
// *                                                                           *
// * The Initial Developer of the Original Code is                             *
// * Steven Tine.                                                              *
// * Portions created by the Initial Developer are Copyright (C) 2006          *
// * the Initial Developer. All Rights Reserved.                               *
// *                                                                           *
// * Contributor(s): Steven Tine                                               *
// *                                                                           *
// **************************END LICENSE BLOCK**********************************

const INVALID_PROFILE_ID="";
const INVALID_PROFILE_NUM=-1;
const COOKIE_SWAP_DIR_NAME="CookieSwap";
const COOKIE_SWAP_DIR_PERMISSIONS = 0700;  //The dir is user r/w/x only

const COOKIE_FILE_PREFACE="cookies_";  //All profile files start with this string
const INACT_COOKIE_FILE_EXT="txt";    //Inactive profiles have this file extension
const ACTV_COOKIE_FILE_EXT="tx1";     //Active profiles have this file extension

const DEF_PROFILE1_FILENAME = COOKIE_FILE_PREFACE + "Profile1" + "." + ACTV_COOKIE_FILE_EXT;
const DEF_PROFILE2_FILENAME = COOKIE_FILE_PREFACE + "Profile2" + "." + INACT_COOKIE_FILE_EXT;
const DEF_PROFILE3_FILENAME = COOKIE_FILE_PREFACE + "Profile3" + "." + INACT_COOKIE_FILE_EXT;

//-------------------CookieProfileContainer class def---------------------
//The CookieProfileContainer class handles keeping track of where all the CookieProfiles
// are stored and determining which profile is active.  
// It also enables the user to add/remove profiles.
//  isPrivate=true is the profile container used when in private browsing
//  isPrivate=false is the profile container used when in normal (non-private) browsing
function CookieProfileContainer(isPrivate)
{
   //Define a debug function for the class...change true/false to turn it on/off
   this.classDump=function(s){true ? cookieswap_dbg("[CookieProfileContainer]" + s) : (s)}

   //This is the way to call the debug function
   this.classDump("START ctor");

   //This will get the directory of the current Mozilla profile.
   //  We'll put the CookieSwap dir under there since Firefox's cookies.txt file
   //  is stored in this profile dir.
   this.profileDir = Components.classes["@mozilla.org/file/directory_service;1"]
                        .getService(Components.interfaces.nsIProperties)
                        .get("ProfD", Components.interfaces.nsIFile);
   this.profileDir.append(COOKIE_SWAP_DIR_NAME);

   //Start out by assuming we are not in Private Browsing Mode
   this._privBrowsing = isPrivate;

   //Initialize the rest of the object   
   this.init();
    
   //This is the way to call the debug function
   this.classDump("END ctor");
}

CookieProfileContainer.prototype.getPrivBrowsing = function()
{
   return this._privBrowsing;
}

//This method initializes the class.  It's outside the ctor because
//  we can reinit the class when the profile list is changed
CookieProfileContainer.prototype.init = function()
{
   this.profileArray = new Array();
   this.activeProfileId = INVALID_PROFILE_ID;

   //If the CookieSwap directory doesn't exist, this is the first time that
   //  the CookieSwap extension has run.  Create the directory and also
   //  create the default profile files.
   if( (this.profileDir.exists() != true) || (this.profileDir.isDirectory() != true) ) 
   { 
      this.classDump("First time CookieSwap has been run...creating " + COOKIE_SWAP_DIR_NAME);

      //Create the directory
      this.profileDir.create(Components.interfaces.nsIFile.DIRECTORY_TYPE, COOKIE_SWAP_DIR_PERMISSIONS);

      //Make a few copies of the directory handle
      var def_profile1 = this.profileDir.clone()
      var def_profile2 = this.profileDir.clone()
      var def_profile3 = this.profileDir.clone()

      //Append the filenames to the directory
      def_profile1.append(DEF_PROFILE1_FILENAME);
      def_profile2.append(DEF_PROFILE2_FILENAME);
      def_profile3.append(DEF_PROFILE3_FILENAME);

      //Now create the default files
      def_profile1.create(Components.interfaces.nsIFile.NORMAL_FILE_TYPE, COOKIE_FILE_PERMISSIONS);
      def_profile2.create(Components.interfaces.nsIFile.NORMAL_FILE_TYPE, COOKIE_FILE_PERMISSIONS);
      def_profile3.create(Components.interfaces.nsIFile.NORMAL_FILE_TYPE, COOKIE_FILE_PERMISSIONS);
   }

   //Let's enumerate through all the files in the CookieSwap directory
   var files = this.profileDir.directoryEntries;
   var i=0;

   this.classDump("Recursing the profileDir..." + files.hasMoreElements());

   while (files.hasMoreElements())
   {
      //Get the next file and QI it to a nsIFile object
      var curr_file = files.getNext();
      curr_file.QueryInterface(Components.interfaces.nsIFile);

      //Convert to convient String
      this.classDump("--File located...Name=" + curr_file.leafName);

      var curr_profile;
      var curr_profile_name;

      //Create a CookieProfile instance with the filename
      if (this._privBrowsing)
      {
         //In priv browsing, create the non persistent CookieProfile
         curr_profile = new PrivateBrowsingCookieProfile(curr_file);
      }
      else
      {
         //Not in priv browsing, create the persistent CookieProfile
         curr_profile = new CookieProfile(curr_file);
      }
 
      //Check to see if the profile is valid
      curr_profile_name = curr_profile.getProfileName(); 
      if (curr_profile_name != "")
      {
         //We have a valid cookie profile file...create the CookieProfile object
         this.profileArray[i] = new Object();
         this.profileArray[i].profile = curr_profile;
         this.profileArray[i].name = curr_profile_name;

         //If the profile is active, track it
         if (curr_profile.getActiveState() == true)
         {
            this.classDump("Profile #" + i + " is active");
            this.activeProfileId = curr_profile_name;
         }

         //Increment the valid profile counter
         i++;
      }
      else
      {
         //It's not valid, free the profile instance
         curr_profile = null;
      } 
   }

   //On some OSes (e.g. Linux), the filesystem doesn't provide the profiles in
   //  alphabetic order.  Reorder the array by name alphabetically.
   this.profileArray.sort(this.sortProfilesAlphabetically);
}

//This method reinitializes the class.  Ideally, this can reinit
//  without needing to go read all the files again, but this
//  is probably the safest way.
//However, we need to not lose the value of the 
//  cookiesCameFromThisSession attribute in the profile class
//  or we will throw away the session cookies on next swap.
CookieProfileContainer.prototype.reinit = function()
{
   var j=0;
   var prof_list_w_session_cookies = new Array();

   this.classDump("Enter reinit()");

   for(var i=0; i<this.profileArray.length; i++)
   {
      var curr_profile = this.profileArray[i];

      if (curr_profile.profile.cookiesCameFromThisSession == true)
      {
         //This profile has valid session cookies.  Store the
         //  profile name for use after init()
         prof_list_w_session_cookies[j] = curr_profile.name;
         j=j+1;
         this.classDump(curr_profile.name + " has valid session cookies");
      }
   }

   //No go reinit the class
   this.classDump("Calling init()");
   this.init();

   for(var i=0; i<this.profileArray.length; i++)
   {
      var curr_profile = this.profileArray[i];

      if (prof_list_w_session_cookies.indexOf(curr_profile.name) != -1)
      {
         //This profile has valid session cookies.
         //  Store that in the profile
         curr_profile.profile.cookiesCameFromThisSession = true;
         this.classDump("Noting that " + curr_profile.name + " has valid session cookies");
      }
   }
}

//This method is passed to the Array.sort() function as a way
// to compare Profiles in the profileArray so they will be re-sorted
// alphabetically.
//If a.name is earlier than b.name in the alphabet return <0
//If a.name is the same as b.name, return 0
//If a.name is after b.name in the alphabet, return >0
CookieProfileContainer.prototype.sortProfilesAlphabetically = function(a,b)
{
  if (a.name.toLowerCase() < b.name.toLowerCase())
    return -1;
  else if (a.name > b.name)
    return 1;
  else
    return 0;
}

//This method returns the number of profiles that exist in this container.
CookieProfileContainer.prototype.getNumOfProfiles = function()
{
   return(this.profileArray.length); 
}

//This method returns a string that is the name of the profileID passed in.
//  null is returned if the profileID is invalid.
CookieProfileContainer.prototype.getProfileName = function(profileNum)
{
   if (profileNum < this.profileArray.length)
   {
      return(this.profileArray[profileNum].name);
   }
   else
   {
      this.classDump("Invalid Num (" + profileNum + ") passed in to getProfileName of " + this.profileArray.length);
      return(null);
   }
}

//This method returns the number of the profile whose name was passed in.
//  null is returned if the profileID is invalid.
CookieProfileContainer.prototype.getProfileNum = function(profileId)
{
   var prof_num=INVALID_PROFILE_NUM;
 
   if (profileId != INVALID_PROFILE_ID)
   {
      //Search the profileArray for the passed in ID
      for(var i=0; i<this.profileArray.length; i++)
      {
         if (this.profileArray[i].name == profileId)
            prof_num = i;   //Found the profileName
      }

      //If after searching the array we still didn't find the ID...it's an error
      if (prof_num == INVALID_PROFILE_NUM)
      {
         this.classDump("ERROR Invalid Name '" + profileId + "' passed in to getProfileNum. Len=" + this.profileArray.length);
      }
   }

   return(prof_num);
}

//This method returns a CookieProfile class object corresponding to the profileID
//  passed in.  If not profile with that profileID exists, null is returned.
CookieProfileContainer.prototype.getProfile = function(profileId)
{
   var profile_num = this.getProfileNum(profileId);

   if (profile_num < this.profileArray.length)
   {
      return(this.profileArray[profile_num].profile);
   }
   else
   {
      this.classDump("Invalid ID (" + profileId + "which translated to " + profile_num + ") passed in to getProfile of " + this.profileArray.length);
      return(null);
   }
}

//This method adds a CookieProfile object with the passed in name.
//  If success, true is returned and the caller should expect the profile list to have changed.
CookieProfileContainer.prototype.addProfile = function(profileName)
{
   this.classDump("addProfile(" + profileName + ")");
  
   var ret_val=false;
 
   //First make sure the profile name doesn't already exist
   if (this.getProfileNum(profileName) == INVALID_PROFILE_NUM)
   {
      //Make a copy of the profileDir
      var new_profile = this.profileDir.clone()

      //Add to the directory the filename associated with the new profile and create it
      new_profile.append(CookieProfile_getLeafFileName(profileName, false));
      
      this.classDump("Creating: " + new_profile.path);

      new_profile.create(Components.interfaces.nsIFile.NORMAL_FILE_TYPE, COOKIE_FILE_PERMISSIONS);

      //Now reinit the class to pick up the new profile
      this.reinit();
      ret_val = true;
   }

   return(ret_val);
}

//This method removes the CookieProfile object with the passed in num.
// Retval:  true:  Success, the call should assume the profile list has changed
//          false: Error
CookieProfileContainer.prototype.removeProfile = function(profileNum)
{
   this.classDump("removeProfile(" + profileNum + ")");//Still need to perform file operations
   
   var ret_val=false;
   var active_num = this.getProfileNum(this.activeProfileId);
 
   //See if the profileNum passed in is valid and that it's not the active profile 
   if (profileNum >= 0 && profileNum < this.profileArray.length && active_num != profileNum)
   {
      //Delete the profile's file
      this.classDump("Removing the profile");
      this.profileArray[profileNum].profile.remove();

      //Now reinit the class to pick up the change
      this.reinit();
      ret_val = true;
   }
   else
   {
      this.classDump("Invalid ID or ID of the active profile passed in to removeProfile");
   }

   return(ret_val);
}

//Change the name on the passed in profileNum.
// Retval:  true:  Success, the call should assume the profile list has changed
//          false: Error
CookieProfileContainer.prototype.renameProfile = function(profileNum, newProfileName)
{
   this.classDump("renameProfile(" + 
                  profileNum + "," + newProfileName + ")");
   var ret_val=false;
   var active_num = this.getProfileNum(this.activeProfileId);

   if (profileNum >= 0 && profileNum < this.profileArray.length)
   {
      //Make the name change
      this.profileArray[profileNum].profile.rename(newProfileName);
      this.profileArray[profileNum].name = newProfileName;

      //Now reinit the class to pick up the change
      this.reinit();
      ret_val = true;
   }
   else
   {
      this.classDump("Invalid ID passed in to renameProfile");
   }

   return(ret_val);
}

//Copy the passed in profileNum.
// Retval:  true:  Success, the call should assume the profile list has changed
//          false: Error
CookieProfileContainer.prototype.copyProfile = function(profileNum, newProfileName)
{
   this.classDump("copyProfile(" + 
                  profileNum + "," + newProfileName + ")");
   var ret_val=false;
   var active_num = this.getProfileNum(this.activeProfileId);

   if (profileNum >= 0 && profileNum < this.profileArray.length)
   {
      //First make sure the new profile name doesn't already exist
      if (this.getProfileNum(newProfileName) == INVALID_PROFILE_NUM)
      {
         //Make the copy
         this.profileArray[profileNum].profile.copy(newProfileName);

         //Now reinit the class to pick up the new profile
         this.reinit();
         ret_val = true;
      }
   }
   else
   {
      this.classDump("Invalid ID passed in to copyProfile");
   }

   return(ret_val);
}

//Returns the profileID of the active profile
CookieProfileContainer.prototype.getActiveProfileId = function()
{
   return(this.activeProfileId);
}

//Changes the active profile to the profileID pased in.  The active profileID
//  is returned.  If it doesn't match the profileId passed in, then it was
//  not accepted as a valid profile to make active.
CookieProfileContainer.prototype.setActiveProfileId = function(new_profile_id)
{
   this.classDump("START setActiveProfileId( " + new_profile_id + ")");

   var old_profile_id = this.activeProfileId;
   var old_profile_num = this.getProfileNum(old_profile_id);
   this.classDump("Old profile '" + old_profile_id + "' is num " + old_profile_num);

   var new_profile_num = this.getProfileNum(new_profile_id);
   this.classDump("New profile '" + new_profile_id + "' is num " + new_profile_num);

   //If the currently active profile is valid, rename that profile's filename to indicate
   //  that is no longer the active profile
   if ((old_profile_id != INVALID_PROFILE_ID)  && (old_profile_num < this.profileArray.length))
   {
      //Set the old profile to no longer be active
      this.profileArray[old_profile_num].profile.setActiveState(false);
   }

   //If the new profileID is valid, rename that profile's file to indicate that it
   //  is the active profile
   if ((new_profile_num != INVALID_PROFILE_NUM)  && (new_profile_num < this.profileArray.length))
   {
      this.profileArray[new_profile_num].profile.setActiveState(true);
   }
   else
   {
      //The profile passed in is not valid.
      //This is an error condition unless we are swapping to the INVALID_PROFILE_ID
      if (new_profile_id != INVALID_PROFILE_ID)
      {
         this.classDump("ERROR Invalid ID '" + new_profile_id + "' passed in to setActiveProfileId");
         new_profile_id = INVALID_PROFILE_ID;  //Non-valid ID passed in, make it INVALID
      }
   }
      
   this.activeProfileId = new_profile_id;
   this.classDump("END setActiveProfileId( " + new_profile_id + ")");
   
   return(this.activeProfileId);
}


// *****************************************************************************
// *                        CookieProfile Class                                *
// *                                                                           *
// ************************** Coding Standards *********************************
// *  gMyVariable     - global variable (starts with "g", then mixed case)     *
// *  myVariable      - variables passed into functions                        *
// *  my_variable     - local variable inside of a function                    *
// *  this.myVariable - class attributes/variable (mixed case & always         *
// *                    referenced with "this.")                               *
// *  MyFunction      - functions are always mixed case                        *
// *  MY_CONSTANT     - constants are all caps with underscores                *
// *                                                                           *
// *************************** Revision History ********************************
// *  Name       Date       BugzID  Action                                     *
// *  ---------  ---------  -----   ------                                     *
// *  SteveTine  28Dec2005  12561   Initial Creation                           *
// *  SteveTine  11Jan2006  12720   Fixing the way session cookies are handled *
// *  SteveTine  30Sep2006  15281   Adding setFileHandle method                *
// *  SteveTine  16Jan2006  Trac9   Create cs_Cookie instead of Cookie class   *
// *                                                                           *
// ************************* BEGIN LICENSE BLOCK *******************************
// * Version: MPL 1.1                                                          *
// *                                                                           *
// *The contents of this file are subject to the Mozilla Public License Version*
// * 1.1 (the "License"); you may not use this file except in compliance with  *
// * the License. You may obtain a copy of the License at                      *
// * http://www.mozilla.org/MPL/                                               *
// *                                                                           *
// * Software distributed under the License is distributed on an "AS IS" basis,*
// * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License  *
// * for the specific language governing rights and limitations under the      *
// * License.                                                                  *
// *                                                                           *
// * The Original Code is the CookieSwap Mozilla/Firefox Extension             *
// *                                                                           *
// * The Initial Developer of the Original Code is                             *
// * Steven Tine.                                                              *
// * Portions created by the Initial Developer are Copyright (C) 2006          *
// * the Initial Developer. All Rights Reserved.                               *
// *                                                                           *
// * Contributor(s): Steven Tine                                               *
// *                                                                           *
// **************************END LICENSE BLOCK**********************************

const FLAGS_PR_RDONLY      = 0x01; //Open for reading only.
const FLAGS_PR_WRONLY      = 0x02; //Open for writing only.
const FLAGS_PR_RDWR        = 0x04; //Open for reading and writing.
const FLAGS_PR_CREATE_FILE = 0x08; //If the file does not exist, the file is created.
const FLAGS_PR_APPEND      = 0x10; //The file pointer is set to the end of the file prior to each write.
const FLAGS_PR_TRUNCATE    = 0x20; //If the file exists, its length is truncated to 0.
const FLAGS_PR_SYNC        = 0x40; //If set, each write will wait for both the file data and file status 
                                   //  to be physically updated.
const FLAGS_PR_EXCL        = 0x80; //With PR_CREATE_FILE, if the file does not exist, the file is created. 
                                   //  If the file already exists, no action and NULL is returned

const COOKIE_FILE_PERMISSIONS = 0600;  //User read/write only (matches Linux cookies.txt file perm)
const COOKIE_FILE_READ_FLAGS  = FLAGS_PR_RDONLY;
const COOKIE_FILE_WRITE_FLAGS = FLAGS_PR_WRONLY | FLAGS_PR_CREATE_FILE | FLAGS_PR_TRUNCATE;

const CS_NEW_LINE = "\n";  //"\r\n"
const COOKIE_FILE_HDR = 
    "#This file was created by the CookieSwap extension...see cookieswap.mozdev.org" + CS_NEW_LINE + 
    "#NOTE: if this file's extension is 'tx1' then this is an" + CS_NEW_LINE + 
    "# active profile and the cookies in here are old and will be overwritten by the " +  CS_NEW_LINE + 
    "# cookies being managed by the browser" + CS_NEW_LINE;

//-------------CookieProfile class definition--------------
//This class abstracts the idea of how a profile is persistently stored.  This class
//  also knows how to copy cookies to/from the browser.
//Input: fileName - nsIFile object where the persistent info of this class is stored
function CookieProfile(fileName)
{
   //Define a debug function for the class...change true/false to turn it on/off
   this.classDump=function(s){true ? cookieswap_dbg("[CookieProfile]" + s) : (s)}

   //This is the way to call the debug function
   this.classDump("START ctor");

   //--Create some attributes

   //nsIFile object identifying where the persistent info of this class is stored
   this.fileName = fileName;

   //We need to keep track of if this is the first time this profile is being
   //  swapped in for this running of the browser.  If the user just started
   //  the browser up and they are swapping in this profile for the first time,
   //  "session" cookies (one that expire at the end of the browser session) should
   //  not be swapped in (they should be deleted).
   //But, if the session cookies were swapped out to this profile in the same browser
   //  session, then they should be swapped in also.
   this.cookiesCameFromThisSession = false;

   //Profile Name attribute...will be set below if the file passed in is a valid
   //  profile.  Callers of this ctor can check the profileName for empty string
   //  to find if this creation failed.
   this.profileName = ""; 

   //Attribte tracking if this profile is currently active
   this.activeState = false; 

   //Convert to convient String
   var leaf_name  = new String(fileName.leafName);
   this.classDump("--CookieProfile file name is =" + leaf_name);

   //Now split off the preface of the filename used for cookie files
   var fname_split = leaf_name.split(COOKIE_FILE_PREFACE);
   this.classDump("Num of split is " + fname_split.length);
    
   //If the split found the preface, then the file is likely a cookie file
   if (fname_split.length > 1)
   {
      //Now split off the extension so we can get the extension and the profile name
      //  If we find more than that, the file is not valid...likely a swap file
      //  left around when someone edited the valid cookie file
      var  split_prof_name = fname_split[1].split(".");

      //At this point, split_prof_name[0 to len-1]=ProfileName, 
      //  split_prof_name[split_prof_name.length-1]=file extension
      //  (this is because there can be multiple dots in the profile)
      //  if there are not at least 2 splits in the filename, then it's not valid
      if(split_prof_name.length >= 2)
      {
         //This function removes the last element from the array (the file extension)
         //  and puts it in profile_ext array.  split_prof_name has the extension portion removed.
         var  profile_ext = split_prof_name.splice(split_prof_name.length-1); 
         //Also convert the only element to a simple string
         profile_ext = profile_ext[0];
 
         //We have a valid cookie profile file...set the attribute
         //Now join the remaining strings with a period (the only time this happens is
         //  when there is a period in the profile_name)
         this.profileName = split_prof_name.join("."); 

         this.classDump("Profile Name=" + this.profile_name + ", ext=" + profile_ext);

         //If the file extension shows it as active, track it
         if (profile_ext == ACTV_COOKIE_FILE_EXT)
         {
            this.classDump("Profile is active");
            this.activeState = true; 
         }
      }
   }

   this.classDump("END ctor");
}

//Returns NsIFile
CookieProfile.prototype.getFileHandle = function()
{
   return(this.fileName);
}

//Sets the NsIFile
CookieProfile.prototype.setFileHandle = function(newFile)
{
   this.fileName = newFile;
}

CookieProfile.prototype.getProfileName = function()
{
   return(this.profileName);
}

CookieProfile.prototype.getActiveState = function()
{
   return(this.activeState);
}

//--Changes the state of this profile being active or not
//  active_state = false, means this profile is no loger active
//  active_state = true, means this profile is now active
CookieProfile.prototype.setActiveState= function(active_state)
{
   if (this.activeState != active_state)
   {
      this.classDump("ActiveState change (and file name change) for " + this.profileName);

      //Active state change
      var fileHandle = this.fileName;

      //Set attribute
      this.activeState = active_state;

      //Renaming filename to indicate new active state
      this.fileName = CookieProfile_moveFile(this.fileName, CookieProfile_getLeafFileName(this.profileName, active_state));
  }
}

CookieProfile.prototype.clearAllCookies = function()
{
   //To clear all the cookies in this profile, create an empty file (which
   //  removes the old file) and then just close it.
   var file_stream = this.getEmptyFile();
   file_stream.close(); 
}

CookieProfile.prototype.getEmptyFile = function()
{
   var file_out_stream = ffGetFileOutputStream();

   //Create an empty file that will contain the profile's cookies
   this.classDump("opening " + this.fileName.leafName + " for writing");
   file_out_stream.init(this.fileName, COOKIE_FILE_WRITE_FLAGS, COOKIE_FILE_PERMISSIONS, 0);

   //Write the header to the file
   tmp_string = COOKIE_FILE_HDR;
   file_out_stream.write(tmp_string, tmp_string.length);

   this.classDump("Header written");

   return(file_out_stream);  //It is assumed the caller will call file_out_stream.close()
}

//NOTE this method will copy all the cookies in the Profile to the browser.  It
//  will NOT delete the cookies currently in the browser so the caller should
//  remove the browser cookies first if that is desired.
CookieProfile.prototype.copyToBrowser = function()
{
   var istream = Components.classes["@mozilla.org/network/file-input-stream;1"]
                           .createInstance(Components.interfaces.nsIFileInputStream);
   var cookie_svc=ffGetCookieService();
   var i=0;
   var file_valid=true;
   
   this.classDump("Opening " + this.fileName.leafName + " file for reading");

   try
   {
      istream.init(this.fileName, COOKIE_FILE_READ_FLAGS, COOKIE_FILE_PERMISSIONS, 0);
      this.classDump("Open, converting to nsILineInputStream");
      istream.QueryInterface(Components.interfaces.nsILineInputStream);
   }
   catch (e)
   {
      this.classDump("init failed=>" + e);
      file_valid=false;
   }
 
   if (file_valid == true)
   {
      this.classDump("Open...reading");

      //read lines into array
      var line = {};
      var hasmore;
   
      do
      {
         hasmore = istream.readLine(line);
         var str_line = new String(line.value);  //Convert to a more convienent String object
     
         //this.classDump("DataRead(" + str_line.length + ")=" + str_line);

         //Make sure there is data on the line and it is not a comment
         if ((str_line.length > 0) && (str_line.charAt(0) != '#'))
         {
            var  curr_cookie = new cs_Cookie(str_line);
        
            if (curr_cookie.isValid == true)
            {
               //If the cookies in the profile file did not come from this session of the browser
               //  and they are session cookies, then we don't want to swap them in.
               if ((this.cookiesCameFromThisSession == false) && (curr_cookie.isSessionCookie() == true) )
               {
                  this.classDump("Excluding session cookie from swap because we are running a new" +
                                 "browser session (" + curr_cookie.getCookieString() + ")" );
               }
               else
               {
                  //this.classDump("Adding cookie=" + curr_cookie.getCookieUrl().spec + "=>" + curr_cookie.getCookieString());
                  var cookie_url = curr_cookie.getCookieUrl();
                  if (cookie_url.spec != "")
                  {
                     cookie_svc.setCookieString(cookie_url, 
                                                null, 
                                                curr_cookie.getCookieString(), 
                                                null);
                     i++;  //Increment the valid cookie count
                  }
                  else
                  {
                     this.classDump("Excluding cookie due to blank URL\n");
                  }               }
            }
            else
            {
               this.classDump("Non-comment line was invalid => " + str_line);
            }
         }
      } while(hasmore);
   
      this.classDump("Closing");
      istream.close();
   }
   else
   {
      alert("[CookieSwap] Warning, unable to locate file associated with selected profile.\n" +
            "Expected filename=" + this.fileName.leafName + "\n" +
            "Full path=" + this.fileName.path);
      this.classDump("Unable to open " + this.fileName.path);
   }

   this.classDump("Copied " + i + " cookies from the profile to the browser" );

}

//This method will copy all the cookies in the browser's memory to the
// persistent storage of this profile (replacing all that were
// currently in the storage)
CookieProfile.prototype.copyFromBrowser = function()
{
   var cookie_mgr = ffGetCookieManager();
   var cookie_iter = cookie_mgr.enumerator;
   var curr_cookie;
   var i;
   var file_out_stream = this.getEmptyFile();  //Empty file to store the cookies

   for (i=0;cookie_iter.hasMoreElements();i++)
   {
      curr_cookie = cookie_iter.getNext();

      //Cast the cookie (sorry for the "C" term) to an nsICookie
      if (curr_cookie instanceof Components.interfaces.nsICookie)
      {
          var tmp_string;
          var tmp_cookie;
   
          //this.classDump("Constructing new cookie");

          //Conver the cookie to a "cs_Cookie" class so we can get the FileString
          tmp_cookie = new cs_Cookie(curr_cookie);
          //this.classDump("I have the new cookie");

          //Append the cookie to the global cookie store
          tmp_string = tmp_cookie.getCookieFileString() + CS_NEW_LINE;
          file_out_stream.write(tmp_string, tmp_string.length);
      }
   }

   //Need to keep track that the cookies in the profile were taken from this
   //  running of the browser session.  See the attribute definition for more
   //  details on this.
   this.cookiesCameFromThisSession = true;

   this.classDump("Copied " + i + " cookies from browser to the profile file");
   file_out_stream.close();
}

//This "static" method will take in the profile name and provide a filename.
//  The name will differ if the profile is active (active=true) or not
function CookieProfile_getLeafFileName(profileName, active)
{
   var  file_extension;
   if (active == true)
   {
      file_extension = ACTV_COOKIE_FILE_EXT;
   }
   else
   {
      file_extension = INACT_COOKIE_FILE_EXT;
   }

   return(COOKIE_FILE_PREFACE + profileName + "." + file_extension);
}

//"Static" function to move a file
function CookieProfile_moveFile(fileHandle, newFileName)
{
   cookieswap_dbg("---move start (from '" + fileHandle.leafName + "' to '" +  newFileName + "')---");

   //Actually rename the file to the new name
   fileHandle.moveTo(null, newFileName);

   //On certain OSs (i.e. Linux), the call to moveTo does not update the fileHandle to point
   //  to the new file.  In that case, update it manually
   if (fileHandle.leafName != newFileName)
   {
      //Replace the existing filename portion of the path with the new filename portion of the path
      newFilePath = fileHandle.path.replace(fileHandle.leafName, newFileName);

      cookieswap_dbg("Needing to update fileHandle on this OS from '" + fileHandle.path + "' to '" + newFilePath);

      //Create a new nsIFile object and point it to the new file
      fileHandle = Components.classes["@mozilla.org/file/local;1"].createInstance(Components.interfaces.nsILocalFile);
      fileHandle.initWithPath(newFilePath);
   }

   cookieswap_dbg("---move end---");
   return(fileHandle);
}

//"Static" function to copy a file
function CookieProfile_copyFile(fileHandle, newFileName)
{
   cookieswap_dbg("---copy start (from '" + fileHandle.leafName + "' to '" +  newFileName + "')---");

   //Actually rename the file to the new name
   fileHandle.copyTo(null, newFileName);

   cookieswap_dbg("---copy end---");
}

//This method removes the profile from existance.
//  The caller should not use this profile after calling this method
CookieProfile.prototype.remove = function()
{
   //The request is to remove this profile.  Delete the profile's file.
   this.fileName.remove(false);
}

//This method removes the profile from existance.
//  The caller should not use this profile after calling this method
CookieProfile.prototype.rename = function(newProfileName)
{
   //Make the name change
      
   var newFileName = CookieProfile_getLeafFileName(newProfileName, this.activeState);

   this.classDump("Moving:" + this.fileName.path + " to " + newFileName);
   this.fileName = CookieProfile_moveFile(this.fileName, newFileName);

   this.profileName = newProfileName;
}

//This method copies the profile file to a new file.
CookieProfile.prototype.copy = function(newProfileName)
{
   //Copy the file   
   var newFileName = CookieProfile_getLeafFileName(newProfileName, this.activeState);

   this.classDump("Copying:" + this.fileName.path + " to " + newFileName);
   CookieProfile_copyFile(this.fileName, newFileName);
}

// *****************************************************************************
// *                 PrivateBrowsingCookieProfile Class                        *
// * (implements the CookieProfile interface but does so with no file storage) *
// *                                                                           *
// ************************** Coding Standards *********************************
// *  gMyVariable     - global variable (starts with "g", then mixed case)     *
// *  myVariable      - variables passed into functions                        *
// *  my_variable     - local variable inside of a function                    *
// *  this.myVariable - class attributes/variable (mixed case & always         *
// *                    referenced with "this.")                               *
// *  MyFunction      - functions are always mixed case                        *
// *  MY_CONSTANT     - constants are all caps with underscores                *
// *                                                                           *
// *************************** Revision History ********************************
// *  Name       Date       BugzID  Action                                     *
// *  ---------  ---------  -----   ------                                     *
// *  SteveTine  28Dec2005  12561   Initial Creation                           *
// *  SteveTine  11Jan2006  12720   Fixing the way session cookies are handled *
// *  SteveTine  30Sep2006  15281   Adding setFileHandle method                *
// *  SteveTine  16Jan2006  Trac9   Create cs_Cookie instead of Cookie class   *
// *                                                                           *
// ************************* BEGIN LICENSE BLOCK *******************************
// * Version: MPL 1.1                                                          *
// *                                                                           *
// *The contents of this file are subject to the Mozilla Public License Version*
// * 1.1 (the "License"); you may not use this file except in compliance with  *
// * the License. You may obtain a copy of the License at                      *
// * http://www.mozilla.org/MPL/                                               *
// *                                                                           *
// * Software distributed under the License is distributed on an "AS IS" basis,*
// * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License  *
// * for the specific language governing rights and limitations under the      *
// * License.                                                                  *
// *                                                                           *
// * The Original Code is the CookieSwap Mozilla/Firefox Extension             *
// *                                                                           *
// * The Initial Developer of the Original Code is                             *
// * Steven Tine.                                                              *
// * Portions created by the Initial Developer are Copyright (C) 2006          *
// * the Initial Developer. All Rights Reserved.                               *
// *                                                                           *
// * Contributor(s): Steven Tine                                               *
// *                                                                           *
// **************************END LICENSE BLOCK**********************************

//-------------PrivateBrowsingCookieProfile class definition--------------
//This class abstracts the idea of how a profile is persistently stored.  This class
//  also knows how to copy cookies to/from the browser.
//Input: fileName - nsIFile object where the persistent info of this class is stored
function PrivateBrowsingCookieProfile(fileName)
{
   //Define a debug function for the class...change true/false to turn it on/off
   this.classDump=function(s){true ? cookieswap_dbg("[PrivateBrowsingCookieProfile]" + s) : (s)}

   //This is the way to call the debug function
   this.classDump("START ctor");

   //--Create some attributes
   //nsIFile object identifying where the persistent info of this class is stored
   this.fileName = fileName;

   //Profile Name attribute...will be set below if the file passed in is a valid
   //  profile.  Callers of this ctor can check the profileName for empty string
   //  to find if this creation failed.
   this.profileName = ""; 

   //Attribte tracking if this profile is currently active
   this.activeState = false; 

   //Convert to convient String
   var leaf_name  = new String(fileName.leafName);
   this.classDump("--CookieProfile file name is =" + leaf_name);

   //Now split off the preface of the filename used for cookie files
   var fname_split = leaf_name.split(COOKIE_FILE_PREFACE);
   this.classDump("Num of split is " + fname_split.length);
    
   //If the split found the preface, then the file is likely a cookie file
   if (fname_split.length > 1)
   {
      //Now split off the extension so we can get the extension and the profile name
      //  If we find more than that, the file is not valid...likely a swap file
      //  left around when someone edited the valid cookie file
      var  split_prof_name = fname_split[1].split(".");

      //At this point, split_prof_name[0 to len-1]=ProfileName, 
      //  split_prof_name[split_prof_name.length-1]=file extension
      //  (this is because there can be multiple dots in the profile)
      //  if there are not at least 2 splits in the filename, then it's not valid
      if(split_prof_name.length >= 2)
      {
         //This function removes the last element from the array (the file extension)
         //  and puts it in profile_ext array.  split_prof_name has the extension portion removed.
         var  profile_ext = split_prof_name.splice(split_prof_name.length-1); 
         //Also convert the only element to a simple string
         profile_ext = profile_ext[0];
 
         //We have a valid cookie profile file...set the attribute
         //Now join the remaining strings with a period (the only time this happens is
         //  when there is a period in the profile_name)
         this.profileName = split_prof_name.join("."); 

         this.classDump("Profile Name=" + this.profile_name + ", ext=" + profile_ext);

         //If the file extension shows it as active, track it
         if (profile_ext == ACTV_COOKIE_FILE_EXT)
         {
            this.classDump("Profile is active");
            this.activeState = true; 
         }
      }
   }

   //This is the temporary (in memory only) array of the cookies.
   //  In private browsing, there is no persistent file storage of cookies
   this.cookieArray = new Array();

   this.classDump("END ctor");
}

//Returns NsIFile
PrivateBrowsingCookieProfile.prototype.getFileHandle = function()
{
   return(this.fileName);
}

//Sets the NsIFile
PrivateBrowsingCookieProfile.prototype.setFileHandle = function(newFile)
{
   this.fileName = newFile;
}

PrivateBrowsingCookieProfile.prototype.getProfileName = function()
{
   return(this.profileName);
}

PrivateBrowsingCookieProfile.prototype.getActiveState = function()
{
   return(this.activeState);
}

//--Changes the state of this profile being active or not
//  active_state = false, means this profile is no loger active
//  active_state = true, means this profile is now active
PrivateBrowsingCookieProfile.prototype.setActiveState= function(active_state)
{
   //Set attribute only
   //NO file name change in private browsing because the filename that is showing active is still
   //  active when we leave private browsing.
   this.classDump("ActiveState change (NO file name change in private browsing) for " + this.profileName);
   this.activeState = active_state;
}

PrivateBrowsingCookieProfile.prototype.clearAllCookies = function()
{
   //To clear all the cookies in this profile, create a new array
   this.cookieArray = new Array();
}

PrivateBrowsingCookieProfile.prototype.getEmptyFile = function()
{
   //Not relevant for the PrivateBrowsing version of the class
}

//NOTE this method will copy all the cookies in the Profile to the browser.  It
//  will NOT delete the cookies currently in the browser so the caller should
//  remove the browser cookies first if that is desired.
PrivateBrowsingCookieProfile.prototype.copyToBrowser = function()
{
   var cookie_svc=ffGetCookieService();
   var x;
  
   for (x in this.cookieArray)
   {
      //One by one copy the cookies from the array into Browser Memory
      var  curr_cookie = this.cookieArray[x];
        
      cookie_svc.setCookieString(this.cookieArray[x].CookieUrl, 
                                 null, 
                                 this.cookieArray[x].CookieString, 
                                 null);
   }

   this.classDump("Copied private cookies from the profile to the browser" );

}

//This method will copy all the cookies in the browser's memory to the
// persistent storage of this profile (replacing all that were
// currently in the storage)
PrivateBrowsingCookieProfile.prototype.copyFromBrowser = function()
{
   //Clear the array
   var cookie_mgr = ffGetCookieManager();
   var cookie_iter = cookie_mgr.enumerator;
   var curr_cookie;
   var i;

   this.cookieArray = new Array();
   for (i=0;cookie_iter.hasMoreElements();i++)
   {
      curr_cookie = cookie_iter.getNext();

      //Cast the cookie (sorry for the "C" term) to an nsICookie
      if (curr_cookie instanceof Components.interfaces.nsICookie)
      {
          //One by one copy the cookies from the browser into the array 
          var tmp_cookie;
          var cookie_url;

          //this.classDump("Constructing new cookie");

          //Conver the cookie to a "cs_Cookie" class so we can get the FileString
          tmp_cookie = new cs_Cookie(curr_cookie);

          cookie_url = tmp_cookie.getCookieUrl();
          if (cookie_url.spec != "")
          {
             //Append the cookie to the global cookie store
             this.cookieArray[i] = new Object();
             this.cookieArray[i].CookieUrl = cookie_url;
             this.cookieArray[i].CookieString = tmp_cookie.getCookieString();
          }
          else
          {
             this.classDump("Excluding cookie due to blank URL\n");
          }
      }
   }

   this.classDump("Copied " + i + " cookies from browser to the private profile");
}

//This method removes the profile from existance.
//  The caller should not use this profile after calling this method
PrivateBrowsingCookieProfile.prototype.remove = function()
{
   //Not valid when private browsing
}

//This method removes the profile from existance.
//  The caller should not use this profile after calling this method
PrivateBrowsingCookieProfile.prototype.rename = function(newProfileName)
{
   //Not valid when private browsing
}

// *****************************************************************************
// *                           cs_Cookie Class                                 *
// *                                                                           *
// ************************** Coding Standards *********************************
// *  gMyVariable     - global variable (starts with "g", then mixed case)     *
// *  myVariable      - variables passed into functions                        *
// *  my_variable     - local variable inside of a function                    *
// *  this.myVariable - class attributes/variable (mixed case & always         *
// *                    referenced with "this.")                               *
// *  MyFunction      - functions are always mixed case                        *
// *  MY_CONSTANT     - constants are all caps with underscores                *
// *                                                                           *
// *************************** Revision History ********************************
// *  Name       Date       BugzID  Action                                     *
// *  ---------  ---------  -----   ------                                     *
// *  SteveTine  28Dec2005  12561   Initial Creation                           *
// *  SteveTine  11Jan2006  12720   Fixing the way session cookies are handled *
// *  SteveTine  16Jan2007  Trac9   Changing class name to avoid name clash    *
// *                                                                           *
// ************************* BEGIN LICENSE BLOCK *******************************
// * Version: MPL 1.1                                                          *
// *                                                                           *
// *The contents of this file are subject to the Mozilla Public License Version*
// * 1.1 (the "License"); you may not use this file except in compliance with  *
// * the License. You may obtain a copy of the License at                      *
// * http://www.mozilla.org/MPL/                                               *
// *                                                                           *
// * Software distributed under the License is distributed on an "AS IS" basis,*
// * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License  *
// * for the specific language governing rights and limitations under the      *
// * License.                                                                  *
// *                                                                           *
// * The Original Code is the CookieSwap Mozilla/Firefox Extension             *
// *                                                                           *
// * The Initial Developer of the Original Code is                             *
// * Steven Tine.                                                              *
// * Portions created by the Initial Developer are Copyright (C) 2006          *
// * the Initial Developer. All Rights Reserved.                               *
// *                                                                           *
// * Contributor(s): Steven Tine                                               *
// *                                                                           *
// **************************END LICENSE BLOCK**********************************

//The Date class takes milliseconds, while cookies are stored in seconds.  Use
//  this define to convert from sec to ms.
const SEC_TO_MS_MULT = 1000;
const TAB_FIELD = "\t";

//-------------------cs_Cookie class def---------------------
//  This file contains the definition of the "cs_Cookie" class which
//  provides the ability to input a nsICookie or String consisting of a cookie
//  line in a storage file.  It can then output the cookie in numerous
//  styles:
//  getCookieString-The string style needed by CookieService.setCookieString()
//  getCookieUrl- URI used by CookieService.setCookieString()
//  getCookieFileString-The string style used for storing a cookie in a file
// 
//"cookie" can be a NsICookie or it can be a string that corresponds
//  to the cookie file string returned from a previous instance of
//  this cookie's getCookieFileString() call.
function cs_Cookie(cookie)   
{
   //Define a debug function for the class...change true/false to turn it on/off
   this.classDump=function(s){true ? cookieswap_dbg("[cs_Cookie]" + s) : (s)}

   //This is the way to call the debug function
   this.classDump("START cs_Cookie ctor");

   this.isValid = false;  //Init cookieValid flag to false...the code below will
                                //  change to true if it is found to be valid

   //I'm not sure how to override methods in javascript, so I'll use a run-time
   //  type check to do it
   if (cookie instanceof Components.interfaces.nsICookie)
   {
      //Fill in the attributes of the class based on the attributes of the cookie
      this.expires  = cookie.expires;
      this.host     = cookie.host;
      this.isDomain = cookie.isDomain;
      this.isSecure = cookie.isSecure;
      this.name     = cookie.name;
      this.path     = cookie.path;
      this.policy   = cookie.policy;
      this.status   = cookie.status;
      this.value    = cookie.value;

      this.isValid = true;  //Looks like a good cookie...mark it as valid
   }
   else
   {
      if (cookie.charAt(0) != '#')  //Comment lines start with a "#"
      {
         //Cookie File string format is:
         //  domain <tab> tailmatch <tab> path <tab> secure <tab> expires <tab> name <tab> value
         //   [0]           [1]           [2]         [3]          [4]           [5]        [6]
         var  fields=cookie.split(TAB_FIELD);

         //The split should find at least 6 fields...if not, it is not a valid string
         if (fields.length >= 6)
         {
            this.host     = fields[0];
            this.path     = fields[2];
            this.isSecure = fields[3]=="TRUE" ? true : false;
            this.expires  = fields[4];
            this.isDomain = this.host.charAt(0) == '.' ? true : false;
            this.name     = fields[5];
            this.policy   = null;  //Information is not in the cookieString (I think)
            this.status   = null;  //Information is not in the cookieString (I think)
            this.value    = fields[6];
      
            this.isValid = true;  //Looks like a good cookie...mark it as valid
         }
         else
         {
            this.classDump("Cookie split length is only " + fields.length + " not 6+ in =>" + cookie);
         }
      }
   }

   this.classDump("END cs_Cookie ctor...cookie is " + this.isValid);
}

//Public Methods
//--------------cs_Cookie class methods-------------------
cs_Cookie.prototype.getCookieFileString = function()
{
   this.classDump("START getCookieFileString()");

   //Cookie File format is:
   //  domain <tab> tailmatch <tab> path <tab> secure <tab> expires <tab> name <tab> value
   var cookie_string;

   var tailmatch = this.host.charAt(0) == '.' ? "TRUE" : "FALSE";
   var is_secure = this.isSecure ? "TRUE" : "FALSE"; 
   
   cookie_string = this.host + TAB_FIELD + 
                   tailmatch + TAB_FIELD + 
                   this.path + TAB_FIELD +
                   is_secure + TAB_FIELD +
                   this.expires + TAB_FIELD +
                   this.name + TAB_FIELD +
                   this.value;

   this.classDump("END getCookieFileString()");

   return(cookie_string);
}

//This method returns a string that captures all the attributes of the cookie.  It is a 
//  string that can be used in the setCookieString method of the Cookie Service
cs_Cookie.prototype.getCookieString = function()
{
   this.classDump("START getCookieString()");

   var cookie_string;

   cookie_string = this.name + "=" + this.value + ";";

   //Domain cookies are those that start with ".", like ".google.com"
   if (this.host.charAt(0) == '.')
   {
      cookie_string = cookie_string + "domain=" + this.host + ";";
   }

   //Cookies with an expiration of 0 are "session cookies" that expire at the end of the
   //  session.  Leaving the "expires=" off the string will cause the browser to treat
   //  it as such.
   if (this.expires != 0)
   {
      cookie_string = cookie_string + "expires=" + (new Date(SEC_TO_MS_MULT * this.expires)) + ";";
   }

   cookie_string = cookie_string + "path=" + this.path + ";";

   if (this.isSecure == true)
   {
      cookie_string = cookie_string + "secure;";
   }

   this.classDump("cookie_string=>" + cookie_string + "\nEND getCookieString()");

   return (cookie_string);
}

//This method returns a nsIURI object that is the URL of the cookie
cs_Cookie.prototype.getCookieUrl = function()
{
   this.classDump("START getCookieUrl()");
   var uri = ffGetStandardUrl();

   //In the uri.spec, specify https if secure or http if not
   var http_proto = this.isSecure ? "https://" : "http://";
   if (this.host.charAt(0) == '.')   
   {
      //Starting in FF4, if the domain in the spec has a leading ".", the cookie
      //  won't get added to the cookie store.  The correct domain is included
      //  in the cookie string.
      uri.spec = http_proto + this.host.substring(1) + this.path;
   }
   else
   {
      //Per ticket #78, there was a case where this caused an exception
      //  due to a bad cookie.  Catch that case and return a blank uri.
      try
      {
         uri.spec = http_proto + this.host + this.path;
      }
      catch (e)
      {
         cookieswap_dbgCritical("Setting uri.spec failed=>" + e + "\n");
         cookieswap_dbgCritical("http_proto = " + http_proto + "\n");
         cookieswap_dbgCritical("this.host" + this.host + "\n");
         cookieswap_dbgCritical("this.path" + this.path + "\n");
         cookieswap_dbgCritical("This invalid cookie will not be swapped and will be discarded.\n");
         uri.spec = "";
      }   
   }

   this.classDump("uri.spec=>" + uri.spec + "\nEND getCookieUrl()");

   return(uri);
}

//This method will return if the cookie is a "session" cookie (on that expires
//  at the end of the session) or not
cs_Cookie.prototype.isSessionCookie = function()
{
   //A session cookie is one with an expiration time of 0
   return(this.expires == 0 ? true : false);
}


// *****************************************************************************
// *                           ffComponents                                    *
// * This file provides functions to get easy access to the Mozilla/Firefox(ff)*
// * components (like nsICookieManager and nSICookieService)                   *
// * Obviously these functions aren't doing much work they just help to        *
// * keep the code looking cleaner in the other files.                         *
// * Ideally these would be "C" Macros but I'm not sure how to do that         *
// * in Javascript yet.                                                        *
// *                                                                           *
// ************************** Coding Standards *********************************
// *  gMyVariable     - global variable (starts with "g", then mixed case)     *
// *  myVariable      - variables passed into functions                        *
// *  my_variable     - local variable inside of a function                    *
// *  this.myVariable - class attributes/variable (mixed case & always         *
// *                    referenced with "this.")                               *
// *  MyFunction      - functions are always mixed case                        *
// *  MY_CONSTANT     - constants are all caps with underscores                *
// *                                                                           *
// *************************** Revision History ********************************
// *  Name       Date       BugzID  Action                                     *
// *  ---------  ---------  -----   ------                                     *
// *  SteveTine  2005Dec28  12561   Initial Creation                           *
// *                                                                           *
// ************************* BEGIN LICENSE BLOCK *******************************
// * Version: MPL 1.1                                                          *
// *                                                                           *
// *The contents of this file are subject to the Mozilla Public License Version*
// * 1.1 (the "License"); you may not use this file except in compliance with  *
// * the License. You may obtain a copy of the License at                      *
// * http://www.mozilla.org/MPL/                                               *
// *                                                                           *
// * Software distributed under the License is distributed on an "AS IS" basis,*
// * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License  *
// * for the specific language governing rights and limitations under the      *
// * License.                                                                  *
// *                                                                           *
// * The Original Code is the CookieSwap Mozilla/Firefox Extension             *
// *                                                                           *
// * The Initial Developer of the Original Code is                             *
// * Steven Tine.                                                              *
// * Portions created by the Initial Developer are Copyright (C) 2006          *
// * the Initial Developer. All Rights Reserved.                               *
// *                                                                           *
// * Contributor(s): Steven Tine                                               *
// *                                                                           *
// **************************END LICENSE BLOCK**********************************

function ffGetCookieManager()
{
   return(Components.classes["@mozilla.org/cookiemanager;1"].
                          getService(Components.interfaces.nsICookieManager));
}

function ffGetCookieService()
{
   return(Components.classes["@mozilla.org/cookieService;1"].
                               getService().QueryInterface(Components.interfaces.nsICookieService));

}

function ffGetStandardUrl()
{
   return(Components.classes["@mozilla.org/network/standard-url;1"].createInstance(Components.interfaces.nsIURI));
}

function ffGetUrl(urlString)
{
   return(cookieUri = Components.classes["@mozilla.org/network/io-service;1"]   
           .getService(Components.interfaces.nsIIOService)   
           .newURI(urlString, null, null));   

}

function ffGetDirectoryServiceProvider()
{
   return(Components.classes["@mozilla.org/file/directory_service;1"].createInstance(Components.interfaces.nsIDirectoryServiceProvider));
}

function ffGetFileOutputStream()
{
   return(Components.classes["@mozilla.org/network/file-output-stream;1"].
                              createInstance(Components.interfaces.nsIFileOutputStream));
}


// *****************************************************************************
// *                            csLogger.js                                    *
// * These are the functions that CookieSwap uses to log info/errors           *
// *                                                                           *
// ************************** Coding Standards *********************************
// *  gMyVariable     - global variable (starts with "g", then mixed case)     *
// *  myVariable      - variables passed into functions                        *
// *  my_variable     - local variable inside of a function                    *
// *  this.myVariable - class attributes/variable (mixed case & always         *
// *                    referenced with "this.")                               *
// *  MyFunction      - functions are always mixed case                        *
// *  MY_CONSTANT     - constants are all caps with underscores                *
// *                                                                           *
// *************************** Revision History ********************************
// *  Name       Date       BugzID  Action                                     *
// *  ---------  ---------  -----   ------                                     *
// *  SteveTine  12Apr2009          Initial Creation                           *
// *                                                                           *
// ************************* BEGIN LICENSE BLOCK *******************************
// * Version: MPL 1.1                                                          *
// *                                                                           *
// *The contents of this file are subject to the Mozilla Public License Version*
// * 1.1 (the "License"); you may not use this file except in compliance with  *
// * the License. You may obtain a copy of the License at                      *
// * http://www.mozilla.org/MPL/                                               *
// *                                                                           *
// * Software distributed under the License is distributed on an "AS IS" basis,*
// * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License  *
// * for the specific language governing rights and limitations under the      *
// * License.                                                                  *
// *                                                                           *
// * The Original Code is the CookieSwap Mozilla/Firefox Extension             *
// *                                                                           *
// * The Initial Developer of the Original Code is                             *
// * Steven Tine.                                                              *
// * Portions created by the Initial Developer are Copyright (C) 2006          *
// * the Initial Developer. All Rights Reserved.                               *
// *                                                                           *
// * Contributor(s): Steven Tine                                               *
// *                                                                           *
// **************************END LICENSE BLOCK**********************************


//These values are defaulted here, but read from pref at init
//  These values are only used from extension startup until read from pref
var   gCsDbgEnabled=false;     //Defines if debug is enable or not.    

var   gCsDbgOsConsole=false;   //Defines if we write to the OS console
                               //  via (firefox.exe -console)
var   gCsDbgErrConsole=false;  //Defines if we write to the FF Error Console
                               //  via Tools->Error Console
var   gCsDbgFile=null;         //The file handle to write to if enabled

var   gCsLoggerListener=null; //Observer for logging preferences.
                               // It's global so it can be deleted at close

//Called only per window instance that uses this logger
function cookieswap_loggerInit()
{
   //Register an observer to watch for debug preferences changes
   //  (it calls the observer at startup for each pref)
   gCsLoggerListener = new cookieswap_prefListener("extensions.cookieswap.debug.",
                                                     cookieswap_loggerPrefChanged)
   gCsLoggerListener.register();

   cookieswap_dbg("END cookieswap_init");
}

function cookieswap_loggerClose()
{
   if (gCsLoggerListener != null)
   {
      //This is key to prevent memory leak   
      gCsLoggerListener.unregister();
      gCsLoggerListener=null;
   }

   if (gCsDbgFile != null)
   {
      gCsDbgFile.close();
   }
   gCsDbgFile = null;

}

//This function is called for each logger Pref at startup and each time
//  the preference is changed by the user
function cookieswap_loggerPrefChanged(branch, name)
{
   cookieswap_dbg("loggerPrefChanged(" + branch + "," + name + ")");
   cookieswap_dbg("BEFORE gCsDbgEnabled=" + gCsDbgEnabled + 
                  " gCsDbgErrConsole=" + gCsDbgErrConsole +
                  " gCsDbgOsConsole=" + gCsDbgOsConsole +
                  " gCsDbgFile=" + gCsDbgFile);
   switch (name) 
   {
       case "GeneralBrowserEnable":
           // extensions.cookieswap.debug.GeneralBrowserEnable was changed
           //Not relevant here in the browser/chrome
           break;
       case "GeneralXpcomEnable":
           // extensions.cookieswap.debug.GeneralXpcomEnable was changed
           gCsDbgEnabled = branch.getBoolPref(name);
           break;
       case "ErrorConsole":
           // extensions.cookieswap.debug.ErrorConsole was changed
           //Defines if we write to the Firefox Error Console (Tools->Error Console)
           gCsDbgErrConsole = branch.getBoolPref(name);   
           break;
       case "OsConsole":
           // extensions.cookieswap.debug.OsConsole was changed
           //Defines if we write to the OS console (firefox.exe -console)
           gCsDbgOsConsole = branch.getBoolPref(name);   
           break;
       case "File":
           // extensions.cookieswap.debug.File was changed
           //Defines if we write to a file
           var filename = branch.getCharPref(name);   

           if (filename != "")
           {
              cookieswap_dbg("[cookieswap]: Creating file '" + filename + "'");
              //This will get the directory of the current Mozilla profile.
              //  We'll put the CookieSwap dir under there since Firefox's cookies.txt file
              //  is stored in this profile dir.
              var logFile = Components.classes["@mozilla.org/file/directory_service;1"]
                             .getService(Components.interfaces.nsIProperties)
                             .get("ProfD", Components.interfaces.nsIFile);
              logFile.append(COOKIE_SWAP_DIR_NAME);
              logFile.append(filename);
     
              if (logFile.exists() == true)
              {
                 logFile.remove(true);
              }
              logFile.create(Components.interfaces.nsIFile.NORMAL_FILE_TYPE, COOKIE_FILE_PERMISSIONS);
              cookieswap_dbg("[cookieswap]: Created" );
     
              gCsDbgFile = ffGetFileOutputStream();
              //Open the file with default flags and default permission
              gCsDbgFile.init(logFile, -1, -1, 0);
              cookieswap_dbg("[cookieswap]: Inited" );
           }
           else
           {
              //No filename specified
 
              //If a file is open, close it
              if (gCsDbgFile != null)
              {
                 gCsDbgFile.close();
              }
              gCsDbgFile = null;
           }
           break;
   }

   cookieswap_dbg("AFTER gCsDbgEnabled=" + gCsDbgEnabled + 
                  " gCsDbgErrConsole=" + gCsDbgErrConsole +
                  " gCsDbgOsConsole=" + gCsDbgOsConsole +
                  " gCsDbgFile=" + gCsDbgFile);

}

function cookieswap_turnOnConsoleDebug()
{
   //I don't know the details here...I found this on a Mozilla example web page but it enables
   //  all "dump()" command to be sent to STDOUT and can be seen when firefox.exe is run from a
   //  command window.
   const PREFS_CID      = "@mozilla.org/preferences;1";
   const PREFS_I_PREF   = "nsIPref";
   const PREF_STRING    = "browser.dom.window.dump.enabled";
   try 
   {
       var Pref        = new Components.Constructor(PREFS_CID, PREFS_I_PREF);
       var pref        = new Pref( );
       pref.SetBoolPref(PREF_STRING, true);
   } catch(e) {}

   cookieswap_dbg("Testing STDOUT...debug on!");
}

var gConsoleService = null;
function cookieswap_dbg(str)
{
   //It may seem odd to have one var to turn debug on/off then numerous vars to
   //  decide where to log, but it is designed to optimize the common case where
   //  debug is off.  In that case we only check one variable
   if (gCsDbgEnabled == true)
   {
      var logPrefixString = "[cookieswapmodule]";

      if (gCsDbgErrConsole == true)
      {
         if (gConsoleService == null)
         {
            //To log to the javascript console (Tools->Error Console) get the consoleservice
            gConsoleService = Components.classes["@mozilla.org/consoleservice;1"]
                                       .getService(Components.interfaces.nsIConsoleService);
         }
         gConsoleService.logStringMessage(logPrefixString + str );
      } 

      //--Write to OS console
      if (gCsDbgOsConsole == true)
      {
        dump(logPrefixString + str + "\n");
      }

      //--Write to debug file 
      if (gCsDbgFile != null)
      {
         var tmp_string = logPrefixString + str + "\n";
         gCsDbgFile.write(tmp_string, tmp_string.length);
         gCsDbgFile.flush();
      }
   }
}

//For critical errors, log to the error console no matter what the debug settings
function cookieswap_dbgCritical(str)
{
    var logPrefixString = "[cookieswapmodule-CRITICAL]";

    if (gConsoleService == null)
    {
       //To log to the javascript console (Tools->Error Console) get the consoleservice
       gConsoleService = Components.classes["@mozilla.org/consoleservice;1"]
                                  .getService(Components.interfaces.nsIConsoleService);
    }
    gConsoleService.logStringMessage(logPrefixString + str );
}

function cookieswap_prefListener(branchName, func)
{
    var prefService = Components.classes["@mozilla.org/preferences-service;1"]
                                .getService(Components.interfaces.nsIPrefService);
    var branch = prefService.getBranch(branchName);
    branch.QueryInterface(Components.interfaces.nsIPrefBranch2);

    this.register = function()
    {
        branch.addObserver("", this, false);
        branch.getChildList("", { })
              .forEach(function (name) { func(branch, name); });
    };

    this.unregister = function unregister()
    {
        if (branch)
            branch.removeObserver("", this);
    };

    this.observe = function(subject, topic, data)
    {
        if (topic == "nsPref:changed")
            func(branch, data);
    };
}

function cookieswap_loggerFileClose() 
{
   gCsDbgFile.close();
}

//------Private Browsing Listener (skeleton from MDC)------
// This is only called in FF 19 and earlier.  FF20 totally changed Private Browsing.
function cookieswap_PrivateBrowsingListener() {  
  this.init();  
}  
cookieswap_PrivateBrowsingListener.prototype = {  
  _os: null,  
  _inPrivateBrowsing: false, // whether we are in private browsing mode  
  _watcher: null, // the watcher object  
   
  init : function () {  
    this._inited = true;  
    this._os = Components.classes["@mozilla.org/observer-service;1"]  
                         .getService(Components.interfaces.nsIObserverService);  
    this._os.addObserver(this, "private-browsing", false);  
    this._os.addObserver(this, "quit-application", false);  
    try {  
      var pbs = Components.classes["@mozilla.org/privatebrowsing;1"]  
                          .getService(Components.interfaces.nsIPrivateBrowsingService);  
      this._inPrivateBrowsing = pbs.privateBrowsingEnabled;  
    } catch(ex) {  
      // ignore exceptions in older versions of Firefox  
    }  
  },  
   
  observe : function (aSubject, aTopic, aData) {  
    if (aTopic == "private-browsing") {  
      if (aData == "enter") {  
        this._inPrivateBrowsing = true;  
        if (this.watcher &&  
            "onEnterPrivateBrowsing" in this._watcher) {  
          this.watcher.onEnterPrivateBrowsing();  
        }  
      } else if (aData == "exit") {  
        this._inPrivateBrowsing = false;  
        if (this.watcher &&  
            "onExitPrivateBrowsing" in this._watcher) {  
          this.watcher.onExitPrivateBrowsing();  
        }  
      }  
    } else if (aTopic == "quit-application") {  
      this._os.removeObserver(this, "quit-application");  
      this._os.removeObserver(this, "private-browsing");  
    }  
  },  
   
  get inPrivateBrowsing() {  
    return this._inPrivateBrowsing;  
  },  
   
  get watcher() {  
    return this._watcher;  
  },  
   
  set watcher(val) {  
    this._watcher = val;  
  }  
};  
function cookieswap_initializeVersion(self)
{
  cookieswap_dbg("Entering...cookieswap_initializeVersion()\n");
  try {
      // Firefox 4 and later; Mozilla 2 and later
      cookieswap_dbg("FF4+ Version Check\n");
      Components.utils.import("resource://gre/modules/AddonManager.jsm");
      AddonManager.getAddonByID("cookieSwap@cookieSwap.mozdev.org", function(addon) {
          //This is called async, so it may be some time before this variable is set correctly.
          self._version = addon.version;
          cookieswap_dbg("[Async callback] CookieSwap version is " + self._version + "\n");
          });
  }
  catch (ex) {
      // Firefox 3.6 and before; Mozilla 1.9.2 and before
     cookieswap_dbg("FF3.6 and earlier Version Check\n");
     const extensionManager = Components.classes["@mozilla.org/extensions/manager;1"]
                   .getService(Components.interfaces.nsIExtensionManager);
     self._version = addon.version;
     cookieswap_dbg("CookieSwap version is " + self._version + "\n");
  }
  cookieswap_dbg("Exiting...cookieswap_initializeVersion()\n");
  return;
}

